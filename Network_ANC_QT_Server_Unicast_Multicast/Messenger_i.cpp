// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.0a
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_codegen.cpp:1551

#include "Messenger_i.h"


// Implementation skeleton constructor




Messenger_i::Messenger_i (CORBA::ORB_ptr orb,
                          int instance)
    : instance_ (instance),
    small_request_status_ (0),
    large_request_status_ (0)
{
     MainWindow::orb=orb;
     qRegisterMetaType<CORBALong>("CORBALong");
     connect(this,SIGNAL(MessSent(QString,QString,CORBALong,QString,QString)),MainWindow::parentLocal,SLOT(send_messageSlot(QString,QString,CORBALong,QString,QString)));


     qRegisterMetaType<cmpNEW>("cmpNEW");
     connect(this,SIGNAL(cmdUpdateParametersNewSent(cmpNEW)),MainWindow::parentLocal,SLOT(cmdUpdateParametersNewSlot(cmpNEW)));


     qRegisterMetaType<cmp>("cmp");
     connect(this,SIGNAL(cmdUpdateParametersSent(cmp)),MainWindow::parentLocal,SLOT(cmdUpdateParametersSlot(cmp)));


}

// Implementation skeleton destructor
Messenger_i::~Messenger_i (void)
{
}

::CORBA::Boolean Messenger_i::send_message (
        const char * Name,
        const char * LastName,
        ::CORBA::Long eta,
        const char * subject,
        const char * message)
{


   QString NameEmit(Name);
   QString LastNameEmit(LastName);
   QString subjectEmit(subject);
   QString messageEmit(message);


   emit MessSent(NameEmit,LastNameEmit,eta,subjectEmit,messageEmit);



   return true;

}

void Messenger_i::cmdUpdateParametersNew (
  const ::LocalInterface::CompositeTypes::cmdUpdateParametersCompTypeNew & cmdUpdateParametersParamNew)
{


    emit cmdUpdateParametersNewSent(cmdUpdateParametersParamNew);



}


void Messenger_i::cmdUpdateParameters (
  const ::LocalInterface::CompositeTypes::cmdUpdateParametersCompType & cmdUpdateParametersParam)
{


    emit cmdUpdateParametersSent(cmdUpdateParametersParam);



}


void Messenger_i::cmdUpdateParametersLogic (
  const ::LocalInterface::CompositeTypes::cmdUpdateParametersCompTypeLogic & cmdUpdateParametersParamLogic)
{


    MyRunnableMessageLogicSentBack *task = new MyRunnableMessageLogicSentBack();

    qRegisterMetaType<cmpLogic>("cmpLogic");
    connect(task,SIGNAL(MessageUpdateParametersLogicSentBack(cmpLogic)),MainWindow::parentLocal,SLOT(slotMessageUpdateParametersLogicBackSent(cmpLogic)));
    connect(this,SIGNAL(cmdUpdateParametersLogicSent(cmpLogic)),task,SLOT(slotcmdUpdateParametersLogicSent(cmpLogic)));

    task->setAutoDelete(true);
    emit cmdUpdateParametersLogicSent(cmdUpdateParametersParamLogic);

    QThreadPool::globalInstance()->start(task);


    /*   this is a not a good way to set multiple thread. Evenif the finished thread is terminated. the threads are not organized correctly and the system can crash

    delete cMyObjectMessageLogicBack;
    cMyObjectMessageLogicBack=0;

    mThreadMessageLogicBack  = new QThread();

    cMyObjectMessageLogicBack = new MyObjectMessageLogicBackSent();


    cMyObjectMessageLogicBack->DoSetup(*mThreadMessageLogicBack);
    cMyObjectMessageLogicBack->moveToThread(mThreadMessageLogicBack);

    connect(cMyObjectMessageLogicBack, SIGNAL(destroyed()), mThreadMessageLogicBack, SLOT(quit()));
    connect(mThreadMessageLogicBack, SIGNAL(finished()), mThreadMessageLogicBack, SLOT(deleteLater()));



    mThreadMessageLogicBack->start();

    */


}
